import cv2
import numpy as np
from skimage.util import img_as_float
from skimage.color import rgb2gray
from scipy import signal as sig
from scipy import ndimage as ndi



def Find_Local_Peaks(matrix):

    array_with_the_max_peak_coordinates = np.array(
        [0, 0],
        )
    #print(array_with_the_max_peak_coordinates)
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            #print(matrix[i][j], end=' ')

            if matrix[i][j] >= matrix[array_with_the_max_peak_coordinates[0]][array_with_the_max_peak_coordinates[1]]:
                array_with_the_max_peak_coordinates[0] = i
                array_with_the_max_peak_coordinates[1] = j
    #print(array_with_the_max_peak_coordinates)

    return array_with_the_max_peak_coordinates



def Find_Peaks():
    for i in range(1 ,  len(mat) - 1):
        for j in range(1, len(mat[i]) - 1):

            window_matrix = np.array(mat[i-1:i + 2, j - 1:j + 2])

            max_coord = Find_Local_Peaks(window_matrix)
            print(max_coord)
            for x in range(len(window_matrix)):
                for y in range(len(window_matrix[x])):
                    if x == max_coord[0] and y == max_coord[1]:
                        print("",end=" ")
                    else:
                        mat[x + i - 1][y + j - 1] = 0






def Assign_Orientation(image, interest_point, copy, window_size=16):  #image is an image as an array, and interest_point are the answers as R values in an array the size of image

    height = image.shape[0]
    width = image.shape[1]

    #check if image and interest_point are the same size
    if type(image) != type(interest_point) :
        print("ERROR TYPE INPUTS , NOT SAME  TYPE")



    else :
        print("NO TYPE INPUT ERROR")

    if len(image) != len(interest_point) or len(image[0]) != len(interest_point[0]):
        print("ERROR TYPE INPUTS , NOT SAME  SIZE")
        exit(1)
    else:
        print("NO SIZES INPUT ERROR")



    i = 0
    # for rowindex, responses in enumerate(interest_point):
    #     for colindex, r in enumerate(responses):
    #         if r > 0:
    #             i+=1
    #             print(r)
    #
    # print(i)

    offset = int(window_size / 2)

    for rowindex in range(offset, height + offset):
        for colindex in range(offset, width + offset):

            if interest_point[rowindex - offset, colindex - offset] > 0:
                i += 1
                print(interest_point[rowindex - offset, colindex - offset])
                a = image[rowindex - offset - 1 : rowindex - offset + 3, colindex - offset - 1 : colindex - offset + 3]
                copy[rowindex - offset, colindex - offset] = [0, 255, 0]
    print(i)
    print(a)



def main():
    mat = np.zeros((40, 40), dtype=float)
    mat[-2:, -2:] = 0.5
    mat[16, 16] = 0.8
    filename = input("Name of the image : ")
    img = cv2.imread(filename)
    img_copy = img.copy()
    image_grey = rgb2gray(img)

    print(str(len(mat)) + " " + str(len(mat[0])))
    print(str(len(image_grey)) + " " + str(len(image_grey[0])))
    Assign_Orientation(image_grey, mat, img_copy)

    r = 600 / image_grey.shape[1]
    dim = (600, int(image_grey.shape[0] * r))
    # perform the actual resizing of the image and show it
    resized = cv2.resize(image_grey, dim, interpolation=cv2.INTER_AREA)

    r = 600 / img_copy.shape[1]
    dim = (600, int(img_copy.shape[0] * r))
    # perform the actual resizing of the image and show it
    resized_copy = cv2.resize(img_copy, dim, interpolation=cv2.INTER_AREA)


    cv2.imshow("test_img", resized)
    cv2.imshow("copy", resized_copy)

    if cv2.waitKey(0) & 0xff == 27:
        cv2.destroyAllWindows()

main()
