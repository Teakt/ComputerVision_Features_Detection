import cv2
import numpy as np
from skimage.util import img_as_float
from skimage.color import rgb2gray
from scipy import signal as sig
from scipy import ndimage as ndi

epsilon = 0.000000000000000001

def gradient_x(image_grey):
    sobel_x = np.array((
        [-1, 0, 1],
        [-2, 0, 2],
        [-1, 0, 1]))
    return sig.convolve2d(image_grey, sobel_x, mode="same")

def gradient_y(image_grey):
    sobel_y = np.array((
        [1, 2, 1],
        [0, 0, 0],
        [-1, -2, -1]))
    return sig.convolve2d(image_grey, sobel_y, mode="same")

def Find_Local_Peaks(matrix):

    array_with_the_max_peak_coordinates = np.array(
        [0, 0],
        )
    #print(array_with_the_max_peak_coordinates)
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            #print(matrix[i][j], end=' ')

            if matrix[i][j] >= matrix[array_with_the_max_peak_coordinates[0]][array_with_the_max_peak_coordinates[1]]:
                array_with_the_max_peak_coordinates[0] = i
                array_with_the_max_peak_coordinates[1] = j
    #print(array_with_the_max_peak_coordinates)

    return array_with_the_max_peak_coordinates


def Find_Corners(image , window_size = 20, k=0.04 , tresh = 0) :  # we create a function that will find corners

    #  For each point in the image, consider a window of pixels around that point
    # We choose a window of size 5
    # construct the Sobel x-axis kernel




    cv2.imshow('source_image', image)
    image_grey = rgb2gray(image)
    #cv2.imshow('grey', image_grey)


    img_matrix = np.asarray(image, dtype=float)



    gaussianMask = np.array((
        [1, 4, 7, 4, 1],
        [4, 16, 26, 16, 4],
        [7, 26, 41, 26, 7],
        [4, 16, 26, 16, 4],
        [1, 4, 7, 4, 1],), dtype="int") / 273

    I_x = gradient_x(image_grey)

    I_y = gradient_y(image_grey)


    Ixx = ndi.gaussian_filter(I_x**2, sigma=1)
    Iyy = ndi.gaussian_filter(I_y**2, sigma=1)
    Ixy = ndi.gaussian_filter(I_x*I_y, sigma=1)

    height = image.shape[0]
    width = image.shape[1]





    det = (Ixx * Iyy) - (Ixy ** 2)
    trace = Ixx + Iyy



    c_response =  det /  (trace + epsilon)
    #c_response = det - k*(trace**2)

    tresh = 0.05 * c_response.max()
    
    print(type(c_response))


    offset = int(window_size / 2)

    #print(enumerate(c_response))
    img_copy_for_corners = np.copy(image)
    img_copy_for_edges = np.copy(image)



    for i in range(1, len(c_response) - 1):
        for j in range(1, len(c_response[i]) - 1):

            window_matrix = np.array(c_response[i - 1:i + 2, j - 1:j + 2])

            max_coord = Find_Local_Peaks(window_matrix)
            #print(max_coord)
            for x in range(len(window_matrix)):
                for y in range(len(window_matrix[x])):
                    if x == max_coord[0] and y == max_coord[1]:
                        print("", end=" ")
                    else:
                        c_response[x + i - 1][y + j - 1] = 0

    #print(c_response)

    for rowindex, response in enumerate(c_response):
        for colindex, c in enumerate(response):
            if c > tresh:
                # this is a corner
                img_copy_for_corners[rowindex, colindex] = [255,0,0]

            elif c < 0:
                # this is an edge
                img_copy_for_edges[rowindex, colindex] = [0,255,0]



    cv2.imshow("corners_LOCAL", img_copy_for_corners)



    #print("det" + str(det)  + " trace " + str(trace) + " c " + str(c))
    print("Hauteur" + str(height) + " / " + str(len(img_matrix)) + " Largeur " + str(width))



    if cv2.waitKey(0) & 0xff == 27:
        cv2.destroyAllWindows()

    return img_copy_for_corners


def main():

    filename = input("Name of the image : ")
    img = cv2.imread(filename)


    result = Find_Corners(img)

    cv2.imwrite('forpaint.png', result)


main()