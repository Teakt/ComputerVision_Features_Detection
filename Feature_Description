import cv2
import numpy as np
from skimage.util import img_as_float
from skimage.color import rgb2gray
from scipy import signal as sig
from scipy import ndimage as ndi
import math



epsilon = 0.0001

def gradient_x(image_grey):
    sobel_x = np.array((
        [-1, 0, 1],
        [-2, 0, 2],
        [-1, 0, 1]))
    return sig.convolve2d(image_grey, sobel_x, mode="same")

def gradient_y(image_grey):
    sobel_y = np.array((
        [1, 2, 1],
        [0, 0, 0],
        [-1, -2, -1]))
    return sig.convolve2d(image_grey, sobel_y, mode="same")

def Find_Local_Peaks(matrix):

    array_with_the_max_peak_coordinates = np.array(
        [0, 0],
        )
    #print(array_with_the_max_peak_coordinates)
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            #print(matrix[i][j], end=' ')

            if matrix[i][j] >= matrix[array_with_the_max_peak_coordinates[0]][array_with_the_max_peak_coordinates[1]]:
                array_with_the_max_peak_coordinates[0] = i
                array_with_the_max_peak_coordinates[1] = j
    #print(array_with_the_max_peak_coordinates)

    return array_with_the_max_peak_coordinates


def Find_Corners(image , window_size = 20, k=0.04 ) :  # we create a function that will find corners

    #  For each point in the image, consider a window of pixels around that point
    # We choose a window of size 5
    # construct the Sobel x-axis kernel




    #cv2.imshow('source_image', image)
    image_grey = rgb2gray(image)
    #cv2.imshow('grey', image_grey)


    img_matrix = np.asarray(image, dtype=float)



    gaussianMask = np.array((
        [1, 4, 7, 4, 1],
        [4, 16, 26, 16, 4],
        [7, 26, 41, 26, 7],
        [4, 16, 26, 16, 4],
        [1, 4, 7, 4, 1],), dtype="int") / 273

    I_x = gradient_x(image_grey)

    I_y = gradient_y(image_grey)


    Ixx = ndi.gaussian_filter(I_x**2, sigma=1)
    Iyy = ndi.gaussian_filter(I_y**2, sigma=1)
    Ixy = ndi.gaussian_filter(I_x*I_y, sigma=1)

    height = image.shape[0]
    width = image.shape[1]





    det = (Ixx * Iyy) - (Ixy ** 2)
    trace = Ixx + Iyy



    c_response =  det /  (trace + epsilon)
    #c_response = det - k*(trace**2)

    tresh = 0.2 * c_response.max()
    
    print(type(c_response))


    #offset = int(window_size / 2)

    #print(enumerate(c_response))
    img_copy_for_corners = np.copy(image)
    img_copy_for_edges = np.copy(image)



    for i in range(1, len(c_response) - 1):
        for j in range(1, len(c_response[i]) - 1):

            window_matrix = np.array(c_response[i - 1:i + 2, j - 1:j + 2])

            max_coord = Find_Local_Peaks(window_matrix)
            #print(max_coord)
            for x in range(len(window_matrix)):
                for y in range(len(window_matrix[x])):
                    if x == max_coord[0] and y == max_coord[1]:
                        print("", end=" ")
                    else:
                        c_response[x + i - 1][y + j - 1] = 0

    print(c_response)

    for rowindex, response in enumerate(c_response):
        for colindex, c in enumerate(response):
            if c > tresh:
                # this is a corner
                img_copy_for_corners[rowindex, colindex] = [255,0,0]
                img_copy_for_corners = DrawCircle(img_copy_for_corners, (colindex, rowindex))

            elif c < 0:
                # this is an edge
                img_copy_for_edges[rowindex, colindex] = [0,255,0]



    cv2.imshow("corners_LOCAL", img_copy_for_corners)



    #print("det" + str(det)  + " trace " + str(trace) + " c " + str(c))
    print("Hauteur" + str(height) + " / " + str(len(img_matrix)) + " Largeur " + str(width))





    return c_response


def Assign_Orientation(image_grey, interest_point, copy, window_size=16):  #image is an image as an array, and interest_point are the answers as R values in an array the size of image

    height = image_grey.shape[0]
    width = image_grey.shape[1]

    tresh = 0.2 * interest_point.max()

    #check if image and interest_point are the same size
    if type(image_grey) != type(interest_point) :
        print("ERROR TYPE INPUTS , NOT SAME  TYPE")



    else :
        print("NO TYPE INPUT ERROR")

    if len(image_grey) != len(interest_point) or len(image_grey[0]) != len(interest_point[0]):
        print("ERROR TYPE INPUTS , NOT SAME  SIZE")
        exit(1)
    else:
        print("NO SIZES INPUT ERROR")



    i = 0
    # for rowindex, responses in enumerate(interest_point):
    #     for colindex, r in enumerate(responses):
    #         if r > 0:
    #             i+=1
    #             print(r)
    #
    # print(i)

    offset = int(window_size / 2)
    theta_mat = np.zeros((height, width), dtype=float)
    print(theta_mat)
    for rowindex in range(offset, height - offset):
        for colindex in range(offset, width - offset):

            if interest_point[rowindex , colindex ] > tresh:

                print(interest_point[rowindex , colindex ])
                a = image_grey[rowindex  - 7 : rowindex  + 9, colindex - 7 : colindex  + 9]
                for i in range(len(a)):
                    for j in range(len(a[i])):
                        #copy[rowindex  -7 + i,  colindex - 7 + j] = [255, 0, 255]

                        theta_mat[rowindex  -7 + i,  colindex - 7 + j] = math.atan((image_grey[i][j + 1] - image_grey[i][j - 1])/( (image_grey[i + 1][j] - image_grey[i - 1][j]) + epsilon)) * 180 / math.pi


                copy[rowindex , colindex ] = [0, 255, 0]
                copy = DrawCircle(copy, (colindex , rowindex ), 5 )

    #print(a)
    #print("theta")
    #print(theta_mat)



    for i in range(0 , height):
        for j in range(0, width):
            if theta_mat[i][j] < 0 :
                theta_mat[i][j] += 360

    #print(theta_mat)
    dimensional_descriptor_mat = np.zeros((height, width, 128)
                                          )
    for rowindex in range(offset, height - offset):
        for colindex in range(offset, width - offset):


            if interest_point[rowindex, colindex] > 0:

                window16x16 = theta_mat[rowindex - 7: rowindex + 9, colindex - 7: colindex  + 9]

                divided_mat = blockshaped(window16x16, 4, 4)
                #print(divided_mat)

                concatened_dimensional_descriptor_hist = []
                print(concatened_dimensional_descriptor_hist)
                #we go through that divided array
                for i in range(len(divided_mat)):

                    hist, bin = np.histogram(divided_mat[i], bins=[0, 45, 90, 135, 180, 225, 270, 315, 360])
                    #print(hist)
                    hist = normalize(hist)
                    #hist = Descriptor_Normalized(hist)
                    #print(hist)
                    #print(bin)
                    for value in range(len(hist)): # add EACH CELL's Histogram to the concatened 128 values histogram vector
                        concatened_dimensional_descriptor_hist.append(hist[value])

                concatened_dimensional_descriptor_hist = np.asarray(concatened_dimensional_descriptor_hist)
                print(str(sum(concatened_dimensional_descriptor_hist*concatened_dimensional_descriptor_hist)))
                concatened_dimensional_descriptor_hist  = normalize(concatened_dimensional_descriptor_hist)
                print(str(sum(concatened_dimensional_descriptor_hist * concatened_dimensional_descriptor_hist)))
                concatened_dimensional_descriptor_hist = Descriptor_Normalized(concatened_dimensional_descriptor_hist)
                print(str(sum(concatened_dimensional_descriptor_hist*concatened_dimensional_descriptor_hist)))
                concatened_dimensional_descriptor_hist = normalize(concatened_dimensional_descriptor_hist)
                print(str(sum(concatened_dimensional_descriptor_hist * concatened_dimensional_descriptor_hist)))

                if len(concatened_dimensional_descriptor_hist) != 0:
                    # We put this 128 values array into ITS POSITION IN THE DIMENSIONAL DESCRIPTOR MATRIX at ITS interest point
                    dimensional_descriptor_mat[rowindex][ colindex ] = concatened_dimensional_descriptor_hist
                    #print(dimensional_descriptor_mat)



    return theta_mat, dimensional_descriptor_mat


def Descriptor_Normalized(hist, threshold=0.2): #Treshold normalize the descriptor
    for i in range(len(hist)):
        if hist[i] > 0.2 :
            hist[i] = 0.2
    return  hist


def blockshaped(arr, nrows, ncols):
    """
    Return an array of shape (n, nrows, ncols) where
    n * nrows * ncols = arr.size

    If arr is a 2D array, the returned array should look like n subblocks with
    each subblock preserving the "physical" layout of arr.
    """
    h, w = arr.shape
    assert h % nrows == 0, "{} rows is not evenly divisble by {}".format(h, nrows)
    assert w % ncols == 0, "{} cols is not evenly divisble by {}".format(w, ncols)
    return (arr.reshape(h // nrows, nrows, -1, ncols)
            .swapaxes(1, 2)
            .reshape(-1, nrows, ncols))


def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
       return v
    return v / norm

def DrawCircle(image, center_coordinates, radius=4, color= (0, 255, 0), thickness = 1):

    image = cv2.circle(image, center_coordinates, radius, color, thickness)

    return image


def main():

    filename = input("Name of the image : ")
    img = cv2.imread(filename)
    img_copy = img.copy()
    image_grey = rgb2gray(img)
    matrix_with_C_responses = Find_Corners(img)



    #print(type(matrix_with_C_responses))
    print(str(len(matrix_with_C_responses)) + " " + str(len(matrix_with_C_responses[0])))
    print(str(len(image_grey)) + " " + str(len(image_grey[0])))
    theta_mat, dimensional_descriptor_mat = Assign_Orientation(image_grey, matrix_with_C_responses, img_copy)
    print(theta_mat)
    print(dimensional_descriptor_mat)



    #print(matrix_with_C_responses)

    r = 600 / image_grey.shape[1]
    dim = (600, int(image_grey.shape[0] * r))
    # perform the actual resizing of the image and show it
    resized = cv2.resize(image_grey, dim, interpolation=cv2.INTER_AREA)

    r = 600 / img_copy.shape[1]
    dim = (600, int(img_copy.shape[0] * r))
    # perform the actual resizing of the image and show it
    resized_copy = cv2.resize(img_copy, dim, interpolation=cv2.INTER_AREA)


    cv2.imshow("test_img", resized)
    cv2.imshow("copy", resized_copy)

    if cv2.waitKey(0) & 0xff == 27:
        cv2.destroyAllWindows()



main()

